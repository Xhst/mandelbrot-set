(()=>{"use strict";var e={182:(e,n,r)=>{r.r(n),r.d(n,{default:()=>t});const t="// Define the maximum number of iterations for the Mandelbrot set calculation\r\n// the value between the @ is replaced with the actual value during compilation,\r\n// which can be set by the user in the application, that's because OpenGL doesn't support dynamic loops\r\nconst int MAX_ITERATIONS = @MAX_ITERATIONS@;\r\n\r\n// Set the precision for floating-point operations\r\nprecision mediump float;\r\n\r\n// Uniform variables representing the resolution of the screen,\r\n// scaling factor, and center position of the Mandelbrot set\r\nuniform vec2 resolution;\r\nuniform float scale;\r\nuniform vec2 center;\r\nuniform vec3 colors[16];\r\nuniform vec2 position;\r\n\r\nvoid main() {\r\n    vec2 scale2 = vec2(scale, scale * resolution.y / resolution.x);\r\n\r\n    // Calculate the position of the current pixel in the complex plane\r\n    vec2 z = (gl_FragCoord.xy - resolution / 2.0) * (scale2 / resolution) - center;\r\n    \r\n    // Initialize the iteration count to 0\r\n    int iterations = 0;\r\n    \r\n    // Iterate to determine whether the current pixel is in the Mandelbrot set\r\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\r\n        // Check if the magnitude of z exceeds 2, indicating it's not in the set\r\n        if (length(z) > 2.0) {\r\n            // Exit the loop if the escape condition is met\r\n            break;\r\n        }\r\n            \r\n        // Calculate the next iteration of z using the Mandelbrot formula\r\n        vec2 newZ = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + position;\r\n        \r\n        // Update the value of z for the next iteration\r\n        z = newZ;\r\n        \r\n        // Increment the iteration count\r\n        iterations++;\r\n    }\r\n\r\n    float a = float(iterations) / float(MAX_ITERATIONS);\r\n    vec3 colorV;\r\n\r\n    if (a < 0.0625) {\r\n        colorV = colors[0];\r\n    } else if (a < 0.125) {\r\n        colorV = colors[1];\r\n    } else if (a < 0.1875) {\r\n        colorV = colors[2];\r\n    } else if (a < 0.25) {\r\n        colorV = colors[3];\r\n    } else if (a < 0.3125) {\r\n        colorV = colors[4];\r\n    } else if (a < 0.375) {\r\n        colorV = colors[5];\r\n    } else if (a < 0.4375) {\r\n        colorV = colors[6];\r\n    } else if (a < 0.5) {\r\n        colorV = colors[7];\r\n    } else if (a < 0.5625) {\r\n        colorV = colors[8];\r\n    } else if (a < 0.625) {\r\n        colorV = colors[9];\r\n    } else if (a < 0.6875) {\r\n        colorV = colors[10];\r\n    } else if (a < 0.75) {\r\n        colorV = colors[11];\r\n    } else if (a < 0.8125) {\r\n        colorV = colors[12];\r\n    } else if (a < 0.875) {\r\n        colorV = colors[13];\r\n    } else if (a < 0.9375) {\r\n        colorV = colors[14];\r\n    } else {\r\n        colorV = colors[15];\r\n    }\r\n\r\n    gl_FragColor = vec4(colorV, 1.0);\r\n}\r\n"},882:(e,n,r)=>{r.r(n),r.d(n,{default:()=>t});const t="// Define the maximum number of iterations for the Mandelbrot set calculation\r\n// the value between the @ is replaced with the actual value during compilation,\r\n// which can be set by the user in the application, that's because OpenGL doesn't support dynamic loops\r\nconst int MAX_ITERATIONS = @MAX_ITERATIONS@;\r\n\r\n// Set the precision for floating-point operations\r\nprecision mediump float;\r\n\r\n// Uniform variables representing the resolution of the screen,\r\n// scaling factor, and center position of the Mandelbrot set\r\nuniform vec2 resolution;\r\nuniform float scale;\r\nuniform vec2 center;\r\nuniform vec3 colors[16];\r\nuniform vec2 position;\r\n\r\nvoid main() {\r\n    vec2 scale2 = vec2(scale, scale * resolution.y / resolution.x);\r\n\r\n    // Calculate the position of the current pixel in the complex plane\r\n    vec2 z = (gl_FragCoord.xy - resolution / 2.0) * (scale2 / resolution) - center;\r\n    \r\n    // Initialize the iteration count to 0\r\n    int iterations = 0;\r\n    \r\n    // Iterate to determine whether the current pixel is in the Mandelbrot set\r\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\r\n        // Check if the magnitude of z exceeds 2, indicating it's not in the set\r\n        if (length(z) > 2.0) {\r\n            // Exit the loop if the escape condition is met\r\n            break;\r\n        }\r\n            \r\n        // Calculate the next iteration of z using the Mandelbrot formula\r\n        vec2 newZ = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + position;\r\n        \r\n        // Update the value of z for the next iteration\r\n        z = newZ;\r\n        \r\n        // Increment the iteration count\r\n        iterations++;\r\n    }\r\n\r\n    // Calculate the color based on the number of iterations\r\n    float color = float(iterations) / float(MAX_ITERATIONS);\r\n    \r\n    // Output the final color for the current pixel\r\n    gl_FragColor = vec4(color, color, color, 1.0);\r\n}\r\n"},604:(e,n,r)=>{r.r(n),r.d(n,{default:()=>t});const t="// Define the maximum number of iterations for the Mandelbrot set calculation\r\n// the value between the @ is replaced with the actual value during compilation,\r\n// which can be set by the user in the application, that's because OpenGL doesn't support dynamic loops\r\nconst int MAX_ITERATIONS = @MAX_ITERATIONS@;\r\n\r\n// Set the precision for floating-point operations\r\nprecision mediump float;\r\n\r\n// Uniform variables representing the resolution of the screen,\r\n// scaling factor, and center position of the Mandelbrot set\r\nuniform vec2 resolution;\r\nuniform float scale;\r\nuniform vec2 center;\r\nuniform vec3 colors[16];\r\nuniform vec2 position;\r\n\r\nvoid main() {\r\n    vec2 scale2 = vec2(scale, scale * resolution.y / resolution.x);\r\n\r\n    // Calculate the position of the current pixel in the complex plane\r\n    vec2 z = (gl_FragCoord.xy - resolution / 2.0) * (scale2 / resolution) - center;\r\n    \r\n    // Initialize the iteration count to 0\r\n    int iterations = 0;\r\n    \r\n    // Iterate to determine whether the current pixel is in the Mandelbrot set\r\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\r\n        // Check if the magnitude of z exceeds 2, indicating it's not in the set\r\n        if (length(z) > 2.0) {\r\n            // Exit the loop if the escape condition is met\r\n            break;\r\n        }\r\n            \r\n        // Calculate the next iteration of z using the Mandelbrot formula\r\n        vec2 newZ = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + position;\r\n        \r\n        // Update the value of z for the next iteration\r\n        z = newZ;\r\n        \r\n        // Increment the iteration count\r\n        iterations++;\r\n    }\r\n\r\n    float a = float(iterations) / float(MAX_ITERATIONS);\r\n    vec3 colorV;\r\n\r\n    if (a < 0.0625) {\r\n        colorV = mix(colors[0], colors[1], a);\r\n    } else if (a < 0.125) {\r\n        colorV = mix(colors[1], colors[2], a);\r\n    } else if (a < 0.1875) {\r\n        colorV = mix(colors[2], colors[3], a);\r\n    } else if (a < 0.25) {\r\n        colorV = mix(colors[3], colors[4], a);\r\n    } else if (a < 0.3125) {\r\n        colorV = mix(colors[4], colors[5], a);\r\n    } else if (a < 0.375) {\r\n        colorV = mix(colors[5], colors[6], a);\r\n    } else if (a < 0.4375) {\r\n        colorV = mix(colors[6], colors[7], a);\r\n    } else if (a < 0.5) {\r\n        colorV = mix(colors[7], colors[8], a);\r\n    } else if (a < 0.5625) {\r\n        colorV = mix(colors[8], colors[9], a);\r\n    } else if (a < 0.625) {\r\n        colorV = mix(colors[9], colors[10], a);\r\n    } else if (a < 0.6875) {\r\n        colorV = mix(colors[10], colors[11], a);\r\n    } else if (a < 0.75) {\r\n        colorV = mix(colors[11], colors[12], a);\r\n    } else if (a < 0.8125) {\r\n        colorV = mix(colors[12], colors[13], a);\r\n    } else if (a < 0.875) {\r\n        colorV = mix(colors[13], colors[14], a);\r\n    } else {\r\n        colorV = mix(colors[14], colors[15], a);\r\n    }\r\n\r\n    gl_FragColor = vec4(colorV, 1.0);\r\n}\r\n"},668:(e,n,r)=>{r.r(n),r.d(n,{default:()=>t});const t="// Define the maximum number of iterations for the Mandelbrot set calculation\r\n// the value between the @ is replaced with the actual value during compilation,\r\n// which can be set by the user in the application, that's because OpenGL doesn't support dynamic loops\r\nconst int MAX_ITERATIONS = @MAX_ITERATIONS@;\r\n\r\n// Set the precision for floating-point operations\r\nprecision mediump float;\r\n\r\n// Uniform variables representing the resolution of the screen,\r\n// scaling factor, and center position of the Mandelbrot set\r\nuniform vec2 resolution;\r\nuniform float scale;\r\nuniform vec2 center;\r\nuniform vec3 colors[16];\r\nuniform vec2 position;\r\n\r\nvoid main() {\r\n    vec2 scale2 = vec2(scale, scale * resolution.y / resolution.x);\r\n\r\n    // Calculate the position of the current pixel in the complex plane\r\n    vec2 z = (gl_FragCoord.xy - resolution / 2.0) * (scale2 / resolution) - center;\r\n    \r\n    // Initialize the iteration count to 0\r\n    int iterations = 0;\r\n\r\n    // Initialize the escape radius\r\n    float escapeRadius = 256.0;\r\n    \r\n    // Iterate to determine whether the current pixel is in the Mandelbrot set\r\n    for (int i = 0; i < MAX_ITERATIONS + 2; i++) {\r\n        // Check if the magnitude of z exceeds the escape radius, indicating it's not in the set\r\n        if (length(z) > escapeRadius) {\r\n            // Exit the loop if the escape condition is met\r\n            break;\r\n        }\r\n            \r\n        // Calculate the next iteration of z using the Mandelbrot formula\r\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + position;\r\n        \r\n        // Increment the iteration count\r\n        iterations++;\r\n    }\r\n    \r\n    iterations = iterations - (iterations / 16) * 16;\r\n\r\n    // Calculate the normalized iteration count\r\n    float normalizedIterations = float(iterations) + 1.0 - (log(log(length(z)) / log(2.0))) / log(2.0);\r\n\r\n    vec3 color = vec3(0.0);\r\n    int idx = int(normalizedIterations);\r\n    for (int i = 0; i < 16; i++) {\r\n        if (i == idx) {\r\n            color = mix(colors[i], colors[i + 1], fract(normalizedIterations));\r\n            break;\r\n        }\r\n    }\r\n    \r\n    // Output the final color for the current pixel\r\n    gl_FragColor = vec4(color, 1.0);\r\n}"},205:(e,n,r)=>{r.r(n),r.d(n,{default:()=>t});const t="// Define the maximum number of iterations for the Mandelbrot set calculation\r\n// the value between the @ is replaced with the actual value during compilation,\r\n// which can be set by the user in the application, that's because OpenGL doesn't support dynamic loops\r\nconst int MAX_ITERATIONS = @MAX_ITERATIONS@;\r\n\r\n// Set the precision for floating-point operations\r\nprecision mediump float;\r\n\r\n// Uniform variables representing the resolution of the screen,\r\n// scaling factor, and center position of the Mandelbrot set\r\nuniform vec2 resolution;\r\nuniform float scale;\r\nuniform vec2 center;\r\nuniform vec3 colors[16];\r\n\r\nvoid main() {\r\n\r\n    vec2 scale2 = vec2(scale, scale * resolution.y / resolution.x);\r\n\r\n    // Calculate the position of the current pixel in the complex plane\r\n    vec2 position = (gl_FragCoord.xy - resolution / 2.0) * (scale2 / resolution) - center;\r\n    \r\n    // Initialize the complex number z to (0, 0)\r\n    vec2 z = vec2(0.0, 0.0);\r\n    \r\n    // Initialize the iteration count to 0\r\n    int iterations = 0;\r\n    \r\n    // Iterate to determine whether the current pixel is in the Mandelbrot set\r\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\r\n        // Check if the magnitude of z exceeds 2, indicating it's not in the set\r\n        if (length(z) > 2.0) {\r\n            // Exit the loop if the escape condition is met\r\n            break;\r\n        }\r\n            \r\n        // Calculate the next iteration of z using the Mandelbrot formula\r\n        vec2 newZ = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + position;\r\n        \r\n        // Update the value of z for the next iteration\r\n        z = newZ;\r\n        \r\n        // Increment the iteration count\r\n        iterations++;\r\n    }\r\n\r\n    float a = float(iterations) / float(MAX_ITERATIONS);\r\n    vec3 colorV;\r\n\r\n    if (a < 0.0625) {\r\n        colorV = colors[0];\r\n    } else if (a < 0.125) {\r\n        colorV = colors[1];\r\n    } else if (a < 0.1875) {\r\n        colorV = colors[2];\r\n    } else if (a < 0.25) {\r\n        colorV = colors[3];\r\n    } else if (a < 0.3125) {\r\n        colorV = colors[4];\r\n    } else if (a < 0.375) {\r\n        colorV = colors[5];\r\n    } else if (a < 0.4375) {\r\n        colorV = colors[6];\r\n    } else if (a < 0.5) {\r\n        colorV = colors[7];\r\n    } else if (a < 0.5625) {\r\n        colorV = colors[8];\r\n    } else if (a < 0.625) {\r\n        colorV = colors[9];\r\n    } else if (a < 0.6875) {\r\n        colorV = colors[10];\r\n    } else if (a < 0.75) {\r\n        colorV = colors[11];\r\n    } else if (a < 0.8125) {\r\n        colorV = colors[12];\r\n    } else if (a < 0.875) {\r\n        colorV = colors[13];\r\n    } else if (a < 0.9375) {\r\n        colorV = colors[14];\r\n    } else {\r\n        colorV = colors[15];\r\n    }\r\n\r\n    gl_FragColor = vec4(colorV, 1.0);\r\n}\r\n"},315:(e,n,r)=>{r.r(n),r.d(n,{default:()=>t});const t="// Define the maximum number of iterations for the Mandelbrot set calculation\r\n// the value between the @ is replaced with the actual value during compilation,\r\n// which can be set by the user in the application, that's because OpenGL doesn't support dynamic loops\r\nconst int MAX_ITERATIONS = @MAX_ITERATIONS@;\r\n\r\n// Set the precision for floating-point operations\r\nprecision mediump float;\r\n\r\n// Uniform variables representing the resolution of the screen,\r\n// scaling factor, and center position of the Mandelbrot set\r\nuniform vec2 resolution;\r\nuniform float scale;\r\nuniform vec2 center;\r\nuniform vec3 colors[16];\r\n\r\nvoid main() {\r\n\r\n    vec2 scale2 = vec2(scale, scale * resolution.y / resolution.x);\r\n\r\n    // Calculate the position of the current pixel in the complex plane\r\n    vec2 position = (gl_FragCoord.xy - resolution / 2.0) * (scale2 / resolution) - center;\r\n    \r\n    // Initialize the complex number z to (0, 0)\r\n    vec2 z = vec2(0.0, 0.0);\r\n    \r\n    // Initialize the iteration count to 0\r\n    int iterations = 0;\r\n    \r\n    // Iterate to determine whether the current pixel is in the Mandelbrot set\r\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\r\n        // Check if the magnitude of z exceeds 2, indicating it's not in the set\r\n        if (length(z) > 2.0) {\r\n            // Exit the loop if the escape condition is met\r\n            break;\r\n        }\r\n            \r\n        // Calculate the next iteration of z using the Mandelbrot formula\r\n        vec2 newZ = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + position;\r\n        \r\n        // Update the value of z for the next iteration\r\n        z = newZ;\r\n        \r\n        // Increment the iteration count\r\n        iterations++;\r\n    }\r\n\r\n    // Calculate the color based on the number of iterations\r\n    float color = float(iterations) / float(MAX_ITERATIONS);\r\n\r\n    // Output the final color for the current pixel\r\n    gl_FragColor = vec4(color, color, color, 1.0);\r\n}\r\n"},755:(e,n,r)=>{r.r(n),r.d(n,{default:()=>t});const t="// Define the maximum number of iterations for the Mandelbrot set calculation\r\n// the value between the @ is replaced with the actual value during compilation,\r\n// which can be set by the user in the application, that's because OpenGL doesn't support dynamic loops\r\nconst int MAX_ITERATIONS = @MAX_ITERATIONS@;\r\n\r\n// Set the precision for floating-point operations\r\nprecision mediump float;\r\n\r\n// Uniform variables representing the resolution of the screen,\r\n// scaling factor, and center position of the Mandelbrot set\r\nuniform vec2 resolution;\r\nuniform float scale;\r\nuniform vec2 center;\r\nuniform vec3 colors[16];\r\n\r\nvoid main() {\r\n\r\n    vec2 scale2 = vec2(scale, scale * resolution.y / resolution.x);\r\n\r\n    // Calculate the position of the current pixel in the complex plane\r\n    vec2 position = (gl_FragCoord.xy - resolution / 2.0) * (scale2 / resolution) - center;\r\n    \r\n    // Initialize the complex number z to (0, 0)\r\n    vec2 z = vec2(0.0, 0.0);\r\n    \r\n    // Initialize the iteration count to 0\r\n    int iterations = 0;\r\n    \r\n    // Iterate to determine whether the current pixel is in the Mandelbrot set\r\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\r\n        // Check if the magnitude of z exceeds 2, indicating it's not in the set\r\n        if (length(z) > 2.0) {\r\n            // Exit the loop if the escape condition is met\r\n            break;\r\n        }\r\n            \r\n        // Calculate the next iteration of z using the Mandelbrot formula\r\n        vec2 newZ = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + position;\r\n        \r\n        // Update the value of z for the next iteration\r\n        z = newZ;\r\n        \r\n        // Increment the iteration count\r\n        iterations++;\r\n    }\r\n\r\n    float a = float(iterations) / float(MAX_ITERATIONS);\r\n    vec3 colorV;\r\n\r\n    if (a < 0.0625) {\r\n        colorV = mix(colors[0], colors[1], a);\r\n    } else if (a < 0.125) {\r\n        colorV = mix(colors[1], colors[2], a);\r\n    } else if (a < 0.1875) {\r\n        colorV = mix(colors[2], colors[3], a);\r\n    } else if (a < 0.25) {\r\n        colorV = mix(colors[3], colors[4], a);\r\n    } else if (a < 0.3125) {\r\n        colorV = mix(colors[4], colors[5], a);\r\n    } else if (a < 0.375) {\r\n        colorV = mix(colors[5], colors[6], a);\r\n    } else if (a < 0.4375) {\r\n        colorV = mix(colors[6], colors[7], a);\r\n    } else if (a < 0.5) {\r\n        colorV = mix(colors[7], colors[8], a);\r\n    } else if (a < 0.5625) {\r\n        colorV = mix(colors[8], colors[9], a);\r\n    } else if (a < 0.625) {\r\n        colorV = mix(colors[9], colors[10], a);\r\n    } else if (a < 0.6875) {\r\n        colorV = mix(colors[10], colors[11], a);\r\n    } else if (a < 0.75) {\r\n        colorV = mix(colors[11], colors[12], a);\r\n    } else if (a < 0.8125) {\r\n        colorV = mix(colors[12], colors[13], a);\r\n    } else if (a < 0.875) {\r\n        colorV = mix(colors[13], colors[14], a);\r\n    } else {\r\n        colorV = mix(colors[14], colors[15], a);\r\n    }\r\n\r\n    gl_FragColor = vec4(colorV, 1.0);\r\n}\r\n"},509:(e,n,r)=>{r.r(n),r.d(n,{default:()=>t});const t="// Define the maximum number of iterations for the Mandelbrot set calculation\r\n// the value between the @ is replaced with the actual value during compilation,\r\n// which can be set by the user in the application, that's because OpenGL doesn't support dynamic loops\r\nconst int MAX_ITERATIONS = @MAX_ITERATIONS@;\r\n\r\n// Set the precision for floating-point operations\r\nprecision mediump float;\r\n\r\n// Uniform variables representing the resolution of the screen,\r\n// scaling factor, and center position of the Mandelbrot set\r\nuniform vec2 resolution;\r\nuniform float scale;\r\nuniform vec2 center;\r\nuniform vec3 colors[16];\r\n\r\nvoid main() {\r\n\r\n    vec2 scale2 = vec2(scale, scale * resolution.y / resolution.x);\r\n\r\n    // Calculate the position of the current pixel in the complex plane\r\n    vec2 position = (gl_FragCoord.xy - resolution / 2.0) * (scale2 / resolution) - center;\r\n    \r\n    // Initialize the complex number z to (0, 0)\r\n    vec2 z = vec2(0.0, 0.0);\r\n    \r\n    // Initialize the iteration count to 0\r\n    int iterations = 0;\r\n    \r\n    // Initialize the escape radius\r\n    float escapeRadius = 20.0;\r\n    \r\n    // Iterate to determine whether the current pixel is in the Mandelbrot set\r\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\r\n        // Check if the magnitude of z exceeds the escape radius, indicating it's not in the set\r\n        if (length(z) > escapeRadius) {\r\n            // Exit the loop if the escape condition is met\r\n            break;\r\n        }\r\n            \r\n        // Calculate the next iteration of z using the Mandelbrot formula\r\n        vec2 newZ = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + position;\r\n        \r\n        // Update the value of z for the next iteration\r\n        z = newZ;\r\n        \r\n        // Increment the iteration count\r\n        iterations++;\r\n    }\r\n\r\n    iterations = iterations - (iterations / 16) * 16;\r\n\r\n    // Calculate the normalized iteration count\r\n    float normalizedIterations = float(iterations) + 1.0 - (log(log(length(z)) / log(2.0))) / log(2.0);\r\n\r\n    vec3 color = vec3(0.0);\r\n    int idx = int(normalizedIterations);\r\n    for (int i = 0; i < 16; i++) {\r\n        if (i == idx) {\r\n            color = mix(colors[i], colors[i + 1], fract(normalizedIterations));\r\n            break;\r\n        }\r\n    }\r\n    \r\n    // Output the final color for the current pixel\r\n    gl_FragColor = vec4(color, 1.0);\r\n}\r\n"},450:(e,n,r)=>{r.r(n),r.d(n,{default:()=>t});const t="// Define the attribute for the position of the vertex\r\nattribute vec2 position;\r\n\r\nvoid main() {\r\n    // Set the position of the vertex in clip space\r\n    gl_Position = vec4(position, 0, 1);\r\n}"},253:function(e,n,r){var t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const o=t(r(450)),i=t(r(315)),a=t(r(882)),l=t(r(205)),c=t(r(182)),s=t(r(755)),u=t(r(604)),f=t(r(509)),d=t(r(668)),h=.01;let m=null,p={x:.25,y:0,z:4},g={x:.285,y:.01},v=[{r:9/255,g:1/255,b:47/255},{r:4/255,g:4/255,b:73/255},{r:0,g:7/255,b:100/255},{r:12/255,g:44/255,b:138/255},{r:24/255,g:82/255,b:177/255},{r:57/255,g:125/255,b:209/255},{r:134/255,g:181/255,b:229/255},{r:211/255,g:236/255,b:248/255},{r:241/255,g:233/255,b:191/255},{r:248/255,g:201/255,b:95/255},{r:1,g:170/255,b:0},{r:.8,g:128/255,b:0},{r:.6,g:87/255,b:0},{r:106/255,g:52/255,b:3/255},{r:66/255,g:30/255,b:15/255},{r:25/255,g:7/255,b:26/255}];function x(e){const n=e.getContext("webgl"),r=parseInt(document.getElementById("max-iterations").value);let t;switch(document.getElementById("color-alg").value){default:case"0":t=i.default;break;case"1":t=l.default;break;case"2":t=s.default;break;case"3":t=f.default}w(n,y(n,r,t)),E(e),n.drawArrays(n.TRIANGLE_STRIP,0,4)}function I(e){const n=e.getContext("webgl"),r=parseInt(document.getElementById("max-iterations").value);let t;switch(document.getElementById("color-alg").value){default:case"0":t=a.default;break;case"1":t=c.default;break;case"2":t=u.default;break;case"3":t=d.default}w(n,y(n,r,t)),E(e,g),n.drawArrays(n.TRIANGLE_STRIP,0,4)}function b(){const e=document.createElement("canvas");document.getElementById("canvas-container").appendChild(e);let n=document.getElementById("side-by-side").checked;return e.width=n?window.innerWidth/2:window.innerWidth,e.height=window.innerHeight,e}function z(e,n,r){const t=e.createShader(n);return e.shaderSource(t,r),e.compileShader(t),t}function y(e,n,r){const t=z(e,e.VERTEX_SHADER,o.default),i=z(e,e.FRAGMENT_SHADER,r.replace("@MAX_ITERATIONS@",String(n))),a=e.createProgram();return e.attachShader(a,t),e.attachShader(a,i),e.linkProgram(a),e.useProgram(a),a}function w(e,n){const r=e.getAttribLocation(n,"position"),t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(r),e.vertexAttribPointer(r,2,e.FLOAT,!1,0,0)}function E(e,n=void 0){const r=e.getContext("webgl"),t=r.getParameter(r.CURRENT_PROGRAM),o=r.getUniformLocation(t,"resolution");r.uniform2f(o,e.width,e.height);const i=r.getUniformLocation(t,"scale");r.uniform1f(i,p.z);const a=r.getUniformLocation(t,"center");r.uniform2f(a,p.x,p.y);const l=r.getUniformLocation(t,"colors"),c=v.flatMap((e=>[e.r,e.g,e.b]));if(r.uniform3fv(l,c),null!=n){const e=r.getUniformLocation(t,"position");r.uniform2f(e,n.x,n.y)}}function A(e){const n=e.getContext("webgl"),r=n.getParameter(n.CURRENT_PROGRAM);n.uniform2f(n.getUniformLocation(r,"resolution"),e.width,e.height),n.uniform1f(n.getUniformLocation(r,"scale"),p.z),n.uniform2f(n.getUniformLocation(r,"center"),p.x,p.y),n.drawArrays(n.TRIANGLE_STRIP,0,4)}function T(e,n){g.x=e,g.y=n,document.getElementById("julia-x").value=e.toFixed(6),document.getElementById("julia-y").value=n.toFixed(6)}!function(e,n){document.addEventListener("mouseup",(()=>{m&&clearInterval(m)})),document.addEventListener("touchend",(()=>{m&&clearInterval(m)})),document.getElementById("max-iterations-btn").addEventListener("click",(()=>{const r=parseInt(document.getElementById("max-iterations").value);T(parseFloat(document.getElementById("julia-x").value),parseFloat(document.getElementById("julia-y").value)),console.log("Drawing Mandelbrot set with max iterations:",r),x(e),I(n)})),document.getElementById("side-by-side").addEventListener("change",(()=>{const r=document.getElementById("side-by-side").checked;e.width=r?window.innerWidth/2:window.innerWidth,e.height=window.innerHeight,n.width=r?window.innerWidth/2:window.innerWidth,n.height=window.innerHeight,A(e),A(n)})),document.getElementById("color-alg").addEventListener("change",(()=>{x(e),I(n)})),e.addEventListener("click",(e=>{r(e)})),e.addEventListener("mousedown",(e=>{m=setInterval((()=>{r(e)}),100)})),e.addEventListener("touchstart",(e=>{m=setInterval((()=>{r(e)}),100)}));const r=r=>{const t=e.getBoundingClientRect(),o=(r instanceof MouseEvent?r.clientX:r.touches[0].clientX)-t.left,i=(r instanceof MouseEvent?r.clientY:r.touches[0].clientY)-t.top,a=o,l=e.height-i,c=(a-e.width/2)*(p.z/e.width)-p.x,s=(l-e.height/2)*(p.z/e.width)-p.y;console.log(o,i,c,s),T(c,s),function(e){const n=e.getContext("webgl"),r=n.getParameter(n.CURRENT_PROGRAM);n.uniform1f(n.getUniformLocation(r,"scale"),p.z),n.uniform2f(n.getUniformLocation(r,"center"),p.x,p.y),n.uniform2f(n.getUniformLocation(r,"position"),g.x,g.y),n.drawArrays(n.TRIANGLE_STRIP,0,4)}(n)};document.getElementById("move-down").addEventListener("touchstart",(()=>{m=setInterval((()=>{p.y-=h,A(e),A(n)}),100)})),document.getElementById("move-up").addEventListener("touchstart",(()=>{m=setInterval((()=>{p.y+=h,A(e),A(n)}),100)})),document.getElementById("move-left").addEventListener("touchstart",(()=>{m=setInterval((()=>{p.x-=h,A(e),A(n)}),100)})),document.getElementById("move-right").addEventListener("touchstart",(()=>{m=setInterval((()=>{p.x+=h,A(e),A(n)}),100)})),document.getElementById("zoom-out").addEventListener("touchstart",(()=>{m=setInterval((()=>{p.z-=h,A(e),A(n)}),100)})),document.getElementById("zoom-in").addEventListener("touchstart",(()=>{m=setInterval((()=>{p.z+=h,A(e),A(n)}),100)})),document.getElementById("move-down").addEventListener("mousedown",(()=>{m=setInterval((()=>{p.y-=h,A(e),A(n)}),100)})),document.getElementById("move-up").addEventListener("mousedown",(()=>{m=setInterval((()=>{p.y+=h,A(e),A(n)}),100)})),document.getElementById("move-left").addEventListener("mousedown",(()=>{m=setInterval((()=>{p.x-=h,A(e),A(n)}),100)})),document.getElementById("move-right").addEventListener("mousedown",(()=>{m=setInterval((()=>{p.x+=h,A(e),A(n)}),100)})),document.getElementById("zoom-out").addEventListener("mousedown",(()=>{m=setInterval((()=>{p.z-=h,A(e),A(n)}),100)})),document.getElementById("zoom-in").addEventListener("mousedown",(()=>{m=setInterval((()=>{p.z+=h,A(e),A(n)}),100)})),document.getElementById("move-down").addEventListener("click",(()=>{p.y-=h,A(e),A(n)})),document.getElementById("move-up").addEventListener("click",(()=>{p.y+=h,A(e),A(n)})),document.getElementById("move-left").addEventListener("click",(()=>{p.x-=h,A(e),A(n)})),document.getElementById("move-right").addEventListener("click",(()=>{p.x+=h,A(e),A(n)})),document.getElementById("zoom-out").addEventListener("click",(()=>{p.z-=h,A(e),A(n)})),document.getElementById("zoom-in").addEventListener("click",(()=>{p.z+=h,A(e),A(n)})),window.addEventListener("keydown",(r=>{if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(r.key)||["w","a","s","d"].includes(r.key)||["z","x"].includes(r.key)){switch(r.preventDefault(),r.key){case"ArrowUp":case"w":p.y+=h;break;case"ArrowDown":case"s":p.y-=h;break;case"ArrowLeft":case"a":p.x-=h;break;case"ArrowRight":case"d":p.x+=h;break;case"z":p.z+=h;break;case"x":p.z-=h}A(e),A(n)}}))}(function(){const e=b();if(!e.getContext("webgl"))throw new Error("WebGL not supported");return x(e),e}(),function(){const e=b();if(!e.getContext("webgl"))throw new Error("WebGL not supported");return I(e),e}())}},n={};function r(t){var o=n[t];if(void 0!==o)return o.exports;var i=n[t]={exports:{}};return e[t].call(i.exports,i,i.exports,r),i.exports}r.d=(e,n)=>{for(var t in n)r.o(n,t)&&!r.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},r.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r(253)})();